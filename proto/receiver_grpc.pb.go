// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: receiver.proto

package proto

import (
	context "context"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ReceiverControl_SetLogLevel_FullMethodName               = "/proto.ReceiverControl/SetLogLevel"
	ReceiverControl_GetStatus_FullMethodName                 = "/proto.ReceiverControl/GetStatus"
	ReceiverControl_GetActiveConnectionsCount_FullMethodName = "/proto.ReceiverControl/GetActiveConnectionsCount"
	ReceiverControl_GetConnectedClients_FullMethodName       = "/proto.ReceiverControl/GetConnectedClients"
	ReceiverControl_DisconnectClient_FullMethodName          = "/proto.ReceiverControl/DisconnectClient"
	ReceiverControl_OpenPort_FullMethodName                  = "/proto.ReceiverControl/OpenPort"
	ReceiverControl_ClosePort_FullMethodName                 = "/proto.ReceiverControl/ClosePort"
	ReceiverControl_AddPort_FullMethodName                   = "/proto.ReceiverControl/AddPort"
	ReceiverControl_DeletePort_FullMethodName                = "/proto.ReceiverControl/DeletePort"
)

// ReceiverControlClient is the client API for ReceiverControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис управления RECEIVER'ом
type ReceiverControlClient interface {
	// Устанавливаем уровень логирования, используя общий запрос/ответ
	SetLogLevel(ctx context.Context, in *SetLogLevelRequest, opts ...grpc.CallOption) (*SetLogLevelResponse, error)
	// Получить статус сервиса
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// Получить количество активных подключений
	GetActiveConnectionsCount(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*wrappers.Int32Value, error)
	// Получить список подключенных клиентов
	GetConnectedClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error)
	// Отключить клиента
	DisconnectClient(ctx context.Context, in *DisconnectClientRequest, opts ...grpc.CallOption) (*DisconnectClientResponse, error)
	// Открыть порт (сделать active=true)
	OpenPort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Закрыть порт (сделать active=false)
	ClosePort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Добавить новый порт в конфигурацию (изначально неактивен)
	AddPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Удалить порт из конфигурации
	DeletePort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error)
}

type receiverControlClient struct {
	cc grpc.ClientConnInterface
}

func NewReceiverControlClient(cc grpc.ClientConnInterface) ReceiverControlClient {
	return &receiverControlClient{cc}
}

func (c *receiverControlClient) SetLogLevel(ctx context.Context, in *SetLogLevelRequest, opts ...grpc.CallOption) (*SetLogLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLogLevelResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_SetLogLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetActiveConnectionsCount(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*wrappers.Int32Value, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(wrappers.Int32Value)
	err := c.cc.Invoke(ctx, ReceiverControl_GetActiveConnectionsCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetConnectedClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientsResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_GetConnectedClients_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) DisconnectClient(ctx context.Context, in *DisconnectClientRequest, opts ...grpc.CallOption) (*DisconnectClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectClientResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_DisconnectClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) OpenPort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_OpenPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) ClosePort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_ClosePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) AddPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_AddPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) DeletePort(ctx context.Context, in *PortIdentifier, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_DeletePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReceiverControlServer is the server API for ReceiverControl service.
// All implementations must embed UnimplementedReceiverControlServer
// for forward compatibility.
//
// Сервис управления RECEIVER'ом
type ReceiverControlServer interface {
	// Устанавливаем уровень логирования, используя общий запрос/ответ
	SetLogLevel(context.Context, *SetLogLevelRequest) (*SetLogLevelResponse, error)
	// Получить статус сервиса
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// Получить количество активных подключений
	GetActiveConnectionsCount(context.Context, *GetClientsRequest) (*wrappers.Int32Value, error)
	// Получить список подключенных клиентов
	GetConnectedClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error)
	// Отключить клиента
	DisconnectClient(context.Context, *DisconnectClientRequest) (*DisconnectClientResponse, error)
	// Открыть порт (сделать active=true)
	OpenPort(context.Context, *PortIdentifier) (*PortOperationResponse, error)
	// Закрыть порт (сделать active=false)
	ClosePort(context.Context, *PortIdentifier) (*PortOperationResponse, error)
	// Добавить новый порт в конфигурацию (изначально неактивен)
	AddPort(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// Удалить порт из конфигурации
	DeletePort(context.Context, *PortIdentifier) (*PortOperationResponse, error)
	mustEmbedUnimplementedReceiverControlServer()
}

// UnimplementedReceiverControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReceiverControlServer struct{}

func (UnimplementedReceiverControlServer) SetLogLevel(context.Context, *SetLogLevelRequest) (*SetLogLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLogLevel not implemented")
}
func (UnimplementedReceiverControlServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedReceiverControlServer) GetActiveConnectionsCount(context.Context, *GetClientsRequest) (*wrappers.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveConnectionsCount not implemented")
}
func (UnimplementedReceiverControlServer) GetConnectedClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedClients not implemented")
}
func (UnimplementedReceiverControlServer) DisconnectClient(context.Context, *DisconnectClientRequest) (*DisconnectClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectClient not implemented")
}
func (UnimplementedReceiverControlServer) OpenPort(context.Context, *PortIdentifier) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenPort not implemented")
}
func (UnimplementedReceiverControlServer) ClosePort(context.Context, *PortIdentifier) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosePort not implemented")
}
func (UnimplementedReceiverControlServer) AddPort(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPort not implemented")
}
func (UnimplementedReceiverControlServer) DeletePort(context.Context, *PortIdentifier) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePort not implemented")
}
func (UnimplementedReceiverControlServer) mustEmbedUnimplementedReceiverControlServer() {}
func (UnimplementedReceiverControlServer) testEmbeddedByValue()                         {}

// UnsafeReceiverControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReceiverControlServer will
// result in compilation errors.
type UnsafeReceiverControlServer interface {
	mustEmbedUnimplementedReceiverControlServer()
}

func RegisterReceiverControlServer(s grpc.ServiceRegistrar, srv ReceiverControlServer) {
	// If the following call pancis, it indicates UnimplementedReceiverControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReceiverControl_ServiceDesc, srv)
}

func _ReceiverControl_SetLogLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLogLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).SetLogLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_SetLogLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).SetLogLevel(ctx, req.(*SetLogLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetActiveConnectionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetActiveConnectionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetActiveConnectionsCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetActiveConnectionsCount(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetConnectedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetConnectedClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetConnectedClients_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetConnectedClients(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_DisconnectClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).DisconnectClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_DisconnectClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).DisconnectClient(ctx, req.(*DisconnectClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_OpenPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).OpenPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_OpenPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).OpenPort(ctx, req.(*PortIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_ClosePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).ClosePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_ClosePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).ClosePort(ctx, req.(*PortIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_AddPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).AddPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_AddPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).AddPort(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_DeletePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).DeletePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_DeletePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).DeletePort(ctx, req.(*PortIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

// ReceiverControl_ServiceDesc is the grpc.ServiceDesc for ReceiverControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReceiverControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ReceiverControl",
	HandlerType: (*ReceiverControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetLogLevel",
			Handler:    _ReceiverControl_SetLogLevel_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _ReceiverControl_GetStatus_Handler,
		},
		{
			MethodName: "GetActiveConnectionsCount",
			Handler:    _ReceiverControl_GetActiveConnectionsCount_Handler,
		},
		{
			MethodName: "GetConnectedClients",
			Handler:    _ReceiverControl_GetConnectedClients_Handler,
		},
		{
			MethodName: "DisconnectClient",
			Handler:    _ReceiverControl_DisconnectClient_Handler,
		},
		{
			MethodName: "OpenPort",
			Handler:    _ReceiverControl_OpenPort_Handler,
		},
		{
			MethodName: "ClosePort",
			Handler:    _ReceiverControl_ClosePort_Handler,
		},
		{
			MethodName: "AddPort",
			Handler:    _ReceiverControl_AddPort_Handler,
		},
		{
			MethodName: "DeletePort",
			Handler:    _ReceiverControl_DeletePort_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "receiver.proto",
}
